import discord
from discord.ext import commands
import json
import asyncio
import logging
from datetime import datetime, timedelta

logger = logging.getLogger('discord_bot.moderation')

class Moderation(commands.Cog):
    """Cog pour les commandes de mod√©ration"""
    
    def __init__(self, bot):
        self.bot = bot
    
    async def log_action(self, action, moderator, target, reason=None, duration=None):
        """Envoie un log de l'action de mod√©ration"""
        try:
            logs_channel_id = self.bot.config['channels']['logs']
            if not logs_channel_id:
                return
            
            logs_channel = self.bot.get_channel(logs_channel_id)
            if not logs_channel:
                return
            
            embed = discord.Embed(
                title=f"üî® {action}",
                color=0xe74c3c,
                timestamp=datetime.utcnow()
            )
            
            embed.add_field(name="üë§ Cible", value=f"{target.mention} ({target.name}#{target.discriminator})", inline=True)
            embed.add_field(name="üëÆ Mod√©rateur", value=f"{moderator.mention}", inline=True)
            
            if reason:
                embed.add_field(name="üìù Raison", value=reason, inline=False)
            
            if duration:
                embed.add_field(name="‚è∞ Dur√©e", value=duration, inline=True)
            
            embed.set_thumbnail(url=target.display_avatar.url)
            
            await logs_channel.send(embed=embed)
            
        except Exception as e:
            logger.error(f"Erreur lors de l'envoi du log: {e}")
    
    @commands.command(name='ban')
    @commands.has_permissions(ban_members=True)
    @commands.cooldown(1, 5, commands.BucketType.user)
    async def ban_member(self, ctx, member: discord.Member, *, reason="Aucune raison sp√©cifi√©e"):
        """Bannit un membre du serveur"""
        if member.top_role >= ctx.author.top_role and ctx.author != ctx.guild.owner:
            embed = discord.Embed(
                title="‚ùå Erreur",
                description="Vous ne pouvez pas bannir ce membre (r√¥le sup√©rieur ou √©gal).",
                color=0xe74c3c
            )
            await ctx.send(embed=embed)
            return
        
        if member == ctx.author:
            embed = discord.Embed(
                title="‚ùå Erreur",
                description="Vous ne pouvez pas vous bannir vous-m√™me !",
                color=0xe74c3c
            )
            await ctx.send(embed=embed)
            return
        
        try:
            # Envoie un message priv√© au membre avant le ban
            try:
                dm_embed = discord.Embed(
                    title="üî® Vous avez √©t√© banni",
                    description=f"Vous avez √©t√© banni du serveur **{ctx.guild.name}**",
                    color=0xe74c3c
                )
                dm_embed.add_field(name="üìù Raison", value=reason, inline=False)
                dm_embed.add_field(name="üëÆ Mod√©rateur", value=f"{ctx.author.name}#{ctx.author.discriminator}", inline=False)
                await member.send(embed=dm_embed)
            except discord.Forbidden:
                pass
            
            await member.ban(reason=f"Par {ctx.author}: {reason}")
            
            embed = discord.Embed(
                title="‚úÖ Membre banni",
                description=f"**{member.name}#{member.discriminator}** a √©t√© banni.",
                color=0x2ecc71
            )
            embed.add_field(name="üìù Raison", value=reason, inline=False)
            await ctx.send(embed=embed)
            
            await self.log_action("Bannissement", ctx.author, member, reason)
            logger.info(f"{member.name} banni par {ctx.author.name}")
            
        except discord.Forbidden:
            embed = discord.Embed(
                title="‚ùå Erreur",
                description="Je n'ai pas les permissions pour bannir ce membre.",
                color=0xe74c3c
            )
            await ctx.send(embed=embed)

    @commands.command(name='superban', aliases=['ipban'])
    @commands.has_permissions(administrator=True)
    async def super_ban(self, ctx, member: discord.Member, *, reason="Aucune raison sp√©cifi√©e"):
        """Ban ultra-s√©v√®re avec protection maximale anti-contournement"""
        if member == ctx.author:
            embed = discord.Embed(
                title="‚ùå Erreur",
                description="Vous ne pouvez pas vous super-bannir vous-m√™me !",
                color=0xe74c3c
            )
            await ctx.send(embed=embed)
            return

        if member.top_role >= ctx.author.top_role and not ctx.author.guild_permissions.administrator:
            embed = discord.Embed(
                title="‚ùå Erreur",
                description="Vous ne pouvez pas super-bannir ce membre !",
                color=0xe74c3c
            )
            await ctx.send(embed=embed)
            return

        try:
            # Enregistrer TOUTES les informations possibles
            await self.register_super_ban_info(ctx.guild, member, reason, ctx.author)

            # Message priv√© d'avertissement s√©v√®re
            try:
                dm_embed = discord.Embed(
                    title="‚ö° SUPER-BAN APPLIQU√â",
                    description=f"Vous avez √©t√© **D√âFINITIVEMENT BANNI** du serveur **{ctx.guild.name}**",
                    color=0x8b0000
                )
                dm_embed.add_field(name="üìù Raison", value=reason, inline=False)
                dm_embed.add_field(name="üëÆ Mod√©rateur", value=f"{ctx.author.name}#{ctx.author.discriminator}", inline=False)
                dm_embed.add_field(
                    name="üö® AVERTISSEMENT S√âV√àRE",
                    value="‚Ä¢ Votre empreinte digitale a √©t√© enregistr√©e\n‚Ä¢ Tous vos comptes alternatifs seront automatiquement d√©tect√©s\n‚Ä¢ Toute tentative de contournement entra√Ænera un ban imm√©diat\n‚Ä¢ Cette sanction est D√âFINITIVE et IRR√âVOCABLE",
                    inline=False
                )
                await member.send(embed=dm_embed)
            except:
                pass

            # Ban avec suppression maximale des messages
            await member.ban(reason=f"SUPER-BAN par {ctx.author}: {reason}", delete_message_days=7)

            embed = discord.Embed(
                title="‚ö° SUPER-BAN APPLIQU√â",
                description=f"**{member.name}#{member.discriminator}** a √©t√© d√©finitivement banni avec protection maximale",
                color=0x8b0000
            )
            embed.add_field(name="üìù Raison", value=reason, inline=False)
            embed.add_field(name="üëÆ Mod√©rateur", value=f"{ctx.author.name}#{ctx.author.discriminator}", inline=False)
            embed.add_field(
                name="üõ°Ô∏è Protection Ultra-S√©v√®re Activ√©e",
                value="‚úÖ Empreinte digitale compl√®te enregistr√©e\n‚úÖ D√©tection d'avatar et de comportement\n‚úÖ Surveillance des comptes similaires\n‚úÖ Ban automatique des alts d√©tect√©s\n‚úÖ Historique permanent sauvegard√©",
                inline=False
            )
            embed.add_field(
                name="‚ö†Ô∏è Niveau de Protection",
                value="üî¥ **MAXIMUM** - Contournement quasi-impossible",
                inline=False
            )
            await ctx.send(embed=embed)

            # Log l'action avec niveau critique
            await self.log_action("SUPER-BANNISSEMENT", ctx.author, member, reason)
            logger.critical(f"SUPER-BAN: {ctx.author.name} a super-banni {member.name} pour: {reason}")

        except Exception as e:
            embed = discord.Embed(
                title="‚ùå Erreur Super-Ban",
                description=f"Erreur lors du super-ban: {str(e)}",
                color=0xe74c3c
            )
            await ctx.send(embed=embed)

    async def register_super_ban_info(self, guild, member, reason, moderator):
        """Enregistre TOUTES les informations possibles pour le super-ban"""
        from datetime import datetime

        # R√©cup√©rer les informations d'autorisation si disponibles
        auth_data = {}
        if hasattr(self.bot, 'get_persistent_data'):
            authorized_users = self.bot.get_persistent_data('moderation', 'authorized_users', {})
            if str(member.id) in authorized_users:
                auth_data = authorized_users[str(member.id)]

        super_ban_data = {
            'user_id': member.id,
            'username': str(member),
            'display_name': member.display_name,
            'discriminator': member.discriminator,
            'avatar_hash': str(member.avatar.key) if member.avatar else None,
            'account_created': member.created_at.isoformat(),
            'joined_at': member.joined_at.isoformat() if member.joined_at else None,
            'ban_time': datetime.now().isoformat(),
            'reason': reason,
            'moderator': str(moderator),
            'guild_id': guild.id,
            'ban_type': 'SUPER_BAN',
            'roles': [role.id for role in member.roles if role != guild.default_role],
            'nickname_history': [member.display_name],
            'status': str(member.status) if hasattr(member, 'status') else None,
            'activity': str(member.activity) if hasattr(member, 'activity') and member.activity else None,
            'mutual_guilds_count': len(member.mutual_guilds) if hasattr(member, 'mutual_guilds') else 0,
            'premium_since': member.premium_since.isoformat() if member.premium_since else None,
            'flags': str(member.public_flags) if hasattr(member, 'public_flags') else None,
            # NOUVELLES DONN√âES D'AUTORISATION
            'authorization_data': auth_data,
            'ip_hash': auth_data.get('ip_hash', 'unknown'),
            'user_agent': auth_data.get('user_agent', 'unknown'),
            'authorization_time': auth_data.get('authorization_time', 'unknown'),
            'email_hash': auth_data.get('email_hash', 'unknown'),
            'device_fingerprint': auth_data.get('device_fingerprint', 'unknown')
        }

        # Sauvegarder dans les super-bans
        if hasattr(self.bot, 'set_persistent_data'):
            super_banned = self.bot.get_persistent_data('moderation', 'super_banned_users', {})
            super_banned[str(member.id)] = super_ban_data
            self.bot.set_persistent_data('moderation', 'super_banned_users', super_banned)

            # Aussi dans la liste normale pour compatibilit√©
            banned_users = self.bot.get_persistent_data('moderation', 'banned_users', {})
            banned_users[str(member.id)] = super_ban_data
            self.bot.set_persistent_data('moderation', 'banned_users', banned_users)

    @commands.command(name='banlist')
    @commands.has_permissions(ban_members=True)
    async def ban_list(self, ctx):
        """Affiche la liste des utilisateurs bannis avec d√©tection d'alts"""
        if not hasattr(self.bot, 'get_persistent_data'):
            embed = discord.Embed(
                title="‚ùå Syst√®me non disponible",
                description="Le syst√®me de persistance n'est pas activ√©",
                color=0xe74c3c
            )
            await ctx.send(embed=embed)
            return

        super_banned = self.bot.get_persistent_data('moderation', 'super_banned_users', {})
        banned_users = self.bot.get_persistent_data('moderation', 'banned_users', {})

        if not super_banned and not banned_users:
            embed = discord.Embed(
                title="üìã Liste des Bannis",
                description="Aucun utilisateur banni enregistr√©",
                color=0x95a5a6
            )
            await ctx.send(embed=embed)
            return

        embed = discord.Embed(
            title="üìã LISTE DES UTILISATEURS BANNIS",
            description="Utilisateurs bannis avec syst√®me anti-contournement",
            color=0xe74c3c
        )

        # Super-bans
        if super_banned:
            super_ban_text = ""
            for user_id, data in list(super_banned.items())[:5]:  # Limite √† 5
                username = data.get('username', 'Inconnu')
                reason = data.get('reason', 'Aucune raison')[:50]
                ban_time = data.get('ban_time', '')
                if ban_time:
                    try:
                        from datetime import datetime
                        ban_date = datetime.fromisoformat(ban_time).strftime("%d/%m/%Y")
                    except:
                        ban_date = "Date inconnue"
                else:
                    ban_date = "Date inconnue"

                super_ban_text += f"‚ö° **{username}** (ID: {user_id})\nüìù {reason}\nüìÖ {ban_date}\n\n"

            embed.add_field(
                name="üö® SUPER-BANS (Protection Maximale)",
                value=super_ban_text[:1000] if super_ban_text else "Aucun",
                inline=False
            )

        # Bans normaux
        normal_bans = {k: v for k, v in banned_users.items() if v.get('ban_type') != 'SUPER_BAN'}
        if normal_bans:
            ban_text = ""
            for user_id, data in list(normal_bans.items())[:5]:  # Limite √† 5
                username = data.get('username', 'Inconnu')
                reason = data.get('reason', 'Aucune raison')[:50]
                ban_text += f"üî® **{username}** (ID: {user_id})\nüìù {reason}\n\n"

            embed.add_field(
                name="üî® Bans Normaux",
                value=ban_text[:1000] if ban_text else "Aucun",
                inline=False
            )

        # Statistiques
        total_super = len(super_banned)
        total_normal = len(normal_bans)
        embed.add_field(
            name="üìä Statistiques",
            value=f"‚ö° Super-bans: {total_super}\nüî® Bans normaux: {total_normal}\nüìã Total: {total_super + total_normal}",
            inline=True
        )

        embed.add_field(
            name="üõ°Ô∏è Protection Active",
            value="‚úÖ D√©tection automatique d'alts\n‚úÖ Surveillance des nouveaux comptes\n‚úÖ Ban automatique si d√©tection",
            inline=True
        )

        embed.set_footer(text="Utilisez !superban pour une protection maximale")

        await ctx.send(embed=embed)

    @commands.command(name='unban')
    @commands.has_permissions(ban_members=True)
    async def unban_user(self, ctx, user_id: int, *, reason="Aucune raison sp√©cifi√©e"):
        """D√©bannit un utilisateur et le retire du syst√®me anti-contournement"""
        try:
            # D√©bannir de Discord
            user = await self.bot.fetch_user(user_id)
            await ctx.guild.unban(user, reason=f"Par {ctx.author}: {reason}")

            # Retirer du syst√®me anti-contournement
            if hasattr(self.bot, 'get_persistent_data'):
                super_banned = self.bot.get_persistent_data('moderation', 'super_banned_users', {})
                banned_users = self.bot.get_persistent_data('moderation', 'banned_users', {})

                was_super_banned = str(user_id) in super_banned

                # Retirer des listes
                if str(user_id) in super_banned:
                    del super_banned[str(user_id)]
                    self.bot.set_persistent_data('moderation', 'super_banned_users', super_banned)

                if str(user_id) in banned_users:
                    del banned_users[str(user_id)]
                    self.bot.set_persistent_data('moderation', 'banned_users', banned_users)

            embed = discord.Embed(
                title="‚úÖ Utilisateur d√©banni",
                description=f"**{user.name}#{user.discriminator}** a √©t√© d√©banni",
                color=0x2ecc71
            )
            embed.add_field(name="üìù Raison", value=reason, inline=False)
            embed.add_field(name="üëÆ Mod√©rateur", value=ctx.author.mention, inline=False)

            if was_super_banned:
                embed.add_field(name="üõ°Ô∏è Syst√®me Anti-Contournement", value="‚úÖ Retir√© du syst√®me de d√©tection", inline=False)

            await ctx.send(embed=embed)

            # Log l'action
            await self.log_action("D√âBAN", ctx.author, user, reason)
            logger.info(f"{ctx.author.name} a d√©banni {user.name} pour: {reason}")

        except discord.NotFound:
            embed = discord.Embed(
                title="‚ùå Utilisateur introuvable",
                description="Cet utilisateur n'est pas banni ou n'existe pas",
                color=0xe74c3c
            )
            await ctx.send(embed=embed)
        except Exception as e:
            embed = discord.Embed(
                title="‚ùå Erreur",
                description=f"Erreur lors du d√©ban: {str(e)}",
                color=0xe74c3c
            )
            await ctx.send(embed=embed)

    @commands.command(name='kick')
    @commands.has_permissions(kick_members=True)
    @commands.cooldown(1, 5, commands.BucketType.user)
    async def kick_member(self, ctx, member: discord.Member, *, reason="Aucune raison sp√©cifi√©e"):
        """Expulse un membre du serveur"""
        if member.top_role >= ctx.author.top_role and ctx.author != ctx.guild.owner:
            embed = discord.Embed(
                title="‚ùå Erreur",
                description="Vous ne pouvez pas expulser ce membre (r√¥le sup√©rieur ou √©gal).",
                color=0xe74c3c
            )
            await ctx.send(embed=embed)
            return
        
        if member == ctx.author:
            embed = discord.Embed(
                title="‚ùå Erreur",
                description="Vous ne pouvez pas vous expulser vous-m√™me !",
                color=0xe74c3c
            )
            await ctx.send(embed=embed)
            return
        
        try:
            # Envoie un message priv√© au membre avant le kick
            try:
                dm_embed = discord.Embed(
                    title="üë¢ Vous avez √©t√© expuls√©",
                    description=f"Vous avez √©t√© expuls√© du serveur **{ctx.guild.name}**",
                    color=0xf39c12
                )
                dm_embed.add_field(name="üìù Raison", value=reason, inline=False)
                dm_embed.add_field(name="üëÆ Mod√©rateur", value=f"{ctx.author.name}#{ctx.author.discriminator}", inline=False)
                await member.send(embed=dm_embed)
            except discord.Forbidden:
                pass
            
            await member.kick(reason=f"Par {ctx.author}: {reason}")
            
            embed = discord.Embed(
                title="‚úÖ Membre expuls√©",
                description=f"**{member.name}#{member.discriminator}** a √©t√© expuls√©.",
                color=0x2ecc71
            )
            embed.add_field(name="üìù Raison", value=reason, inline=False)
            await ctx.send(embed=embed)
            
            await self.log_action("Expulsion", ctx.author, member, reason)
            logger.info(f"{member.name} expuls√© par {ctx.author.name}")
            
        except discord.Forbidden:
            embed = discord.Embed(
                title="‚ùå Erreur",
                description="Je n'ai pas les permissions pour expulser ce membre.",
                color=0xe74c3c
            )
            await ctx.send(embed=embed)

    @commands.command(name='mute')
    @commands.has_permissions(manage_roles=True)
    @commands.cooldown(1, 5, commands.BucketType.user)
    async def mute_member(self, ctx, member: discord.Member, duration: int = None, *, reason="Aucune raison sp√©cifi√©e"):
        """Rend muet un membre (dur√©e en minutes)"""
        if member.top_role >= ctx.author.top_role and ctx.author != ctx.guild.owner:
            embed = discord.Embed(
                title="‚ùå Erreur",
                description="Vous ne pouvez pas rendre muet ce membre (r√¥le sup√©rieur ou √©gal).",
                color=0xe74c3c
            )
            await ctx.send(embed=embed)
            return

        if member == ctx.author:
            embed = discord.Embed(
                title="‚ùå Erreur",
                description="Vous ne pouvez pas vous rendre muet vous-m√™me !",
                color=0xe74c3c
            )
            await ctx.send(embed=embed)
            return

        # R√©cup√®re ou cr√©e le r√¥le "Muet"
        muted_role_id = self.bot.config['roles']['muted']
        muted_role = None

        if muted_role_id:
            muted_role = ctx.guild.get_role(muted_role_id)

        if not muted_role:
            # Cr√©e le r√¥le "Muet"
            muted_role = await ctx.guild.create_role(
                name="Muet",
                color=discord.Color.dark_grey(),
                reason="R√¥le de mute automatique"
            )

            # Configure les permissions pour tous les canaux
            for channel in ctx.guild.channels:
                await channel.set_permissions(muted_role, send_messages=False, speak=False)

            # Sauvegarde l'ID du r√¥le
            self.bot.config['roles']['muted'] = muted_role.id
            with open('config.json', 'w', encoding='utf-8') as f:
                json.dump(self.bot.config, f, indent=2, ensure_ascii=False)

        try:
            await member.add_roles(muted_role, reason=f"Par {ctx.author}: {reason}")
            self.bot.muted_users.add(member.id)

            duration_text = f"{duration} minutes" if duration else "Ind√©termin√©e"

            embed = discord.Embed(
                title="üîá Membre rendu muet",
                description=f"**{member.name}#{member.discriminator}** a √©t√© rendu muet.",
                color=0xf39c12
            )
            embed.add_field(name="üìù Raison", value=reason, inline=False)
            embed.add_field(name="‚è∞ Dur√©e", value=duration_text, inline=True)
            await ctx.send(embed=embed)

            await self.log_action("Mute", ctx.author, member, reason, duration_text)

            # D√©mute automatiquement apr√®s la dur√©e sp√©cifi√©e
            if duration:
                await asyncio.sleep(duration * 60)
                if member.id in self.bot.muted_users:
                    await member.remove_roles(muted_role, reason="Fin du mute automatique")
                    self.bot.muted_users.discard(member.id)

                    embed = discord.Embed(
                        title="üîä Mute expir√©",
                        description=f"**{member.name}#{member.discriminator}** n'est plus muet.",
                        color=0x2ecc71
                    )
                    await ctx.send(embed=embed)

            logger.info(f"{member.name} rendu muet par {ctx.author.name}")

        except discord.Forbidden:
            embed = discord.Embed(
                title="‚ùå Erreur",
                description="Je n'ai pas les permissions pour rendre muet ce membre.",
                color=0xe74c3c
            )
            await ctx.send(embed=embed)

    @commands.command(name='unmute')
    @commands.has_permissions(manage_roles=True)
    @commands.cooldown(1, 5, commands.BucketType.user)
    async def unmute_member(self, ctx, member: discord.Member, *, reason="Aucune raison sp√©cifi√©e"):
        """Retire le mute d'un membre"""
        muted_role_id = self.bot.config['roles']['muted']
        if not muted_role_id:
            embed = discord.Embed(
                title="‚ùå Erreur",
                description="Aucun r√¥le de mute configur√©.",
                color=0xe74c3c
            )
            await ctx.send(embed=embed)
            return

        muted_role = ctx.guild.get_role(muted_role_id)
        if not muted_role or muted_role not in member.roles:
            embed = discord.Embed(
                title="‚ùå Erreur",
                description="Ce membre n'est pas muet.",
                color=0xe74c3c
            )
            await ctx.send(embed=embed)
            return

        try:
            await member.remove_roles(muted_role, reason=f"Par {ctx.author}: {reason}")
            self.bot.muted_users.discard(member.id)

            embed = discord.Embed(
                title="üîä Membre d√©mute",
                description=f"**{member.name}#{member.discriminator}** n'est plus muet.",
                color=0x2ecc71
            )
            embed.add_field(name="üìù Raison", value=reason, inline=False)
            await ctx.send(embed=embed)

            await self.log_action("Unmute", ctx.author, member, reason)
            logger.info(f"{member.name} d√©mute par {ctx.author.name}")

        except discord.Forbidden:
            embed = discord.Embed(
                title="‚ùå Erreur",
                description="Je n'ai pas les permissions pour d√©muter ce membre.",
                color=0xe74c3c
            )
            await ctx.send(embed=embed)

    @commands.command(name='clear')
    @commands.has_permissions(manage_messages=True)
    @commands.cooldown(1, 5, commands.BucketType.user)
    async def clear_messages(self, ctx, amount: int = 10):
        """Supprime un nombre de messages (max 100)"""
        if amount > 100:
            embed = discord.Embed(
                title="‚ùå Erreur",
                description="Vous ne pouvez pas supprimer plus de 100 messages √† la fois.",
                color=0xe74c3c
            )
            await ctx.send(embed=embed)
            return

        if amount < 1:
            embed = discord.Embed(
                title="‚ùå Erreur",
                description="Vous devez sp√©cifier un nombre positif de messages √† supprimer.",
                color=0xe74c3c
            )
            await ctx.send(embed=embed)
            return

        try:
            deleted = await ctx.channel.purge(limit=amount + 1)  # +1 pour inclure la commande

            embed = discord.Embed(
                title="üóëÔ∏è Messages supprim√©s",
                description=f"**{len(deleted) - 1}** messages ont √©t√© supprim√©s.",
                color=0x2ecc71
            )

            # Envoie le message de confirmation et le supprime apr√®s 5 secondes
            msg = await ctx.send(embed=embed)
            await asyncio.sleep(5)
            await msg.delete()

            await self.log_action("Clear", ctx.author, ctx.channel, f"{len(deleted) - 1} messages supprim√©s")
            logger.info(f"{len(deleted) - 1} messages supprim√©s par {ctx.author.name} dans {ctx.channel.name}")

        except discord.Forbidden:
            embed = discord.Embed(
                title="‚ùå Erreur",
                description="Je n'ai pas les permissions pour supprimer des messages.",
                color=0xe74c3c
            )
            await ctx.send(embed=embed)

    @commands.command(name='warn')
    @commands.has_permissions(manage_messages=True)
    @commands.cooldown(1, 5, commands.BucketType.user)
    async def warn_member(self, ctx, member: discord.Member, *, reason="Aucune raison sp√©cifi√©e"):
        """Avertit un membre"""
        if member == ctx.author:
            embed = discord.Embed(
                title="‚ùå Erreur",
                description="Vous ne pouvez pas vous avertir vous-m√™me !",
                color=0xe74c3c
            )
            await ctx.send(embed=embed)
            return

        # Ajoute l'avertissement
        if member.id not in self.bot.warnings:
            self.bot.warnings[member.id] = 0

        self.bot.warnings[member.id] += 1
        warning_count = self.bot.warnings[member.id]

        embed = discord.Embed(
            title="‚ö†Ô∏è Membre averti",
            description=f"**{member.name}#{member.discriminator}** a re√ßu un avertissement.",
            color=0xf39c12
        )
        embed.add_field(name="üìù Raison", value=reason, inline=False)
        embed.add_field(name="üìä Avertissements", value=f"{warning_count}/{self.bot.config['moderation']['max_warnings']}", inline=True)

        # V√©rifie si le membre doit √™tre sanctionn√©
        max_warnings = self.bot.config['moderation']['max_warnings']
        if warning_count >= max_warnings:
            embed.add_field(name="üî® Action automatique", value="Membre banni pour trop d'avertissements", inline=False)

            try:
                await member.ban(reason=f"Trop d'avertissements ({warning_count}/{max_warnings})")
                await self.log_action("Ban automatique", self.bot.user, member, f"Trop d'avertissements ({warning_count}/{max_warnings})")
            except discord.Forbidden:
                embed.add_field(name="‚ùå Erreur", value="Impossible de bannir automatiquement ce membre", inline=False)

        await ctx.send(embed=embed)

        # Envoie un message priv√© au membre
        try:
            dm_embed = discord.Embed(
                title="‚ö†Ô∏è Avertissement re√ßu",
                description=f"Vous avez re√ßu un avertissement sur le serveur **{ctx.guild.name}**",
                color=0xf39c12
            )
            dm_embed.add_field(name="üìù Raison", value=reason, inline=False)
            dm_embed.add_field(name="üìä Avertissements", value=f"{warning_count}/{max_warnings}", inline=True)
            dm_embed.add_field(name="üëÆ Mod√©rateur", value=f"{ctx.author.name}#{ctx.author.discriminator}", inline=True)
            await member.send(embed=dm_embed)
        except discord.Forbidden:
            pass

        await self.log_action("Avertissement", ctx.author, member, reason)
        logger.info(f"{member.name} averti par {ctx.author.name} ({warning_count}/{max_warnings})")

    @commands.command(name='warnings')
    @commands.has_permissions(manage_messages=True)
    async def show_warnings(self, ctx, member: discord.Member = None):
        """Affiche les avertissements d'un membre"""
        if not member:
            member = ctx.author

        warning_count = self.bot.warnings.get(member.id, 0)
        max_warnings = 3

        embed = discord.Embed(
            title="‚ö†Ô∏è Avertissements",
            description=f"Avertissements de **{member.name}#{member.discriminator}**",
            color=0xf39c12
        )
        embed.set_thumbnail(url=member.display_avatar.url)
        embed.add_field(
            name="üìä Compteur",
            value=f"{warning_count}/{max_warnings}",
            inline=True
        )

        if warning_count == 0:
            embed.add_field(
                name="‚úÖ Statut",
                value="Aucun avertissement",
                inline=True
            )
        elif warning_count < max_warnings:
            embed.add_field(
                name="‚ö†Ô∏è Statut",
                value=f"Encore {max_warnings - warning_count} avant le ban",
                inline=True
            )
        else:
            embed.add_field(
                name="üî® Statut",
                value="Devrait √™tre banni",
                inline=True
            )

        embed.set_footer(text=f"Demand√© par {ctx.author.name}")
        embed.timestamp = discord.utils.utcnow()

        await ctx.send(embed=embed)
        logger.info(f"Avertissements de {member.name} consult√©s par {ctx.author.name}")

    @commands.Cog.listener()
    async def on_member_join(self, member):
        """D√©tection automatique des comptes alternatifs et contournements de ban"""
        # SYST√àME D'AUTORISATION OBLIGATOIRE
        await self.require_bot_authorization(member)

        # D√âTECTION AUTOMATIQUE DES COMPTES ALTERNATIFS
        await self.check_for_ban_evasion(member)

    async def require_bot_authorization(self, member):
        """Force l'autorisation du bot pour identifier parfaitement l'utilisateur"""
        try:
            # Cr√©er un embed d'autorisation obligatoire
            auth_embed = discord.Embed(
                title="üîê AUTORISATION OBLIGATOIRE REQUISE",
                description=f"**Bienvenue {member.mention} !**\n\nPour acc√©der au serveur, vous devez **OBLIGATOIREMENT** autoriser notre bot √† acc√©der √† vos informations Discord.",
                color=0xff6b6b
            )

            auth_embed.add_field(
                name="üö® POURQUOI C'EST OBLIGATOIRE ?",
                value="‚Ä¢ **S√©curit√© maximale** du serveur\n‚Ä¢ **Identification unique** de votre compte\n‚Ä¢ **Protection anti-contournement** de ban\n‚Ä¢ **Pr√©vention des comptes alternatifs**",
                inline=False
            )

            # Utiliser votre site x10hosting
            auth_url = "https://bot9z.x10.mx/"

            auth_embed.add_field(
                name="üîó LIEN D'AUTORISATION OBLIGATOIRE",
                value=f"[**CLIQUEZ ICI POUR AUTORISER LE BOT**]({auth_url})",
                inline=False
            )

            auth_embed.add_field(
                name="üìã INFORMATIONS COLLECT√âES",
                value="‚Ä¢ **ID Discord unique** (impossible √† falsifier)\n‚Ä¢ **Email associ√©** au compte\n‚Ä¢ **Serveurs en commun**\n‚Ä¢ **Date de cr√©ation** du compte\n‚Ä¢ **Statut de v√©rification** Discord",
                inline=False
            )

            auth_embed.add_field(
                name="‚ö†Ô∏è IMPORTANT",
                value="**Sans cette autorisation, vous ne pourrez PAS acc√©der au serveur.**\nCette mesure garantit la s√©curit√© de tous les membres.",
                inline=False
            )

            auth_embed.set_footer(text="S√©curit√© maximale ‚Ä¢ Protection anti-contournement")

            # Envoyer en DM
            try:
                await member.send(embed=auth_embed)

                # Mettre en quarantaine jusqu'√† autorisation
                quarantine_role = discord.utils.get(member.guild.roles, name="üîê En Attente d'Autorisation")
                if not quarantine_role:
                    quarantine_role = await member.guild.create_role(
                        name="üîê En Attente d'Autorisation",
                        color=0xff6b6b,
                        reason="R√¥le d'attente d'autorisation"
                    )

                    # Aucun acc√®s tant que pas autoris√©
                    for channel in member.guild.channels:
                        try:
                            await channel.set_permissions(quarantine_role, read_messages=False, send_messages=False)
                        except:
                            pass

                await member.add_roles(quarantine_role, reason="En attente d'autorisation bot")

                # Log dans le serveur
                logs_channel = discord.utils.get(member.guild.channels, name="logs")
                if logs_channel:
                    log_embed = discord.Embed(
                        title="üîê AUTORISATION REQUISE",
                        description=f"**{member.name}#{member.discriminator}** doit autoriser le bot",
                        color=0xff6b6b
                    )
                    log_embed.add_field(name="üë§ Utilisateur", value=f"{member.mention} (ID: {member.id})", inline=False)
                    log_embed.add_field(name="üìß DM envoy√©", value="‚úÖ Instructions d'autorisation envoy√©es", inline=False)
                    log_embed.add_field(name="üîí Statut", value="En quarantaine jusqu'√† autorisation", inline=False)
                    await logs_channel.send(embed=log_embed)

            except discord.Forbidden:
                # Si DM impossible, message dans le serveur
                welcome_channel = discord.utils.get(member.guild.channels, name="bienvenue") or member.guild.system_channel
                if welcome_channel:
                    await welcome_channel.send(f"{member.mention}", embed=auth_embed)

        except Exception as e:
            logger.error(f"Erreur autorisation obligatoire: {e}")

    @commands.command(name='authorize_user')
    @commands.has_permissions(administrator=True)
    async def authorize_user_manually(self, ctx, member: discord.Member):
        """Autorise manuellement un utilisateur (admin seulement)"""
        try:
            # Retirer le r√¥le d'attente
            auth_role = discord.utils.get(member.guild.roles, name="üîê En Attente d'Autorisation")
            if auth_role and auth_role in member.roles:
                await member.remove_roles(auth_role, reason=f"Autoris√© manuellement par {ctx.author}")

            # Enregistrer l'autorisation
            if hasattr(self.bot, 'set_persistent_data'):
                authorized_users = self.bot.get_persistent_data('moderation', 'authorized_users', {})
                authorized_users[str(member.id)] = {
                    'user_id': member.id,
                    'username': str(member),
                    'authorized_by': str(ctx.author),
                    'authorization_time': datetime.now().isoformat(),
                    'method': 'manual',
                    'ip_hash': 'manual_auth',  # Pas d'IP pour auth manuelle
                    'user_agent': 'manual_auth'
                }
                self.bot.set_persistent_data('moderation', 'authorized_users', authorized_users)

            embed = discord.Embed(
                title="‚úÖ Utilisateur Autoris√©",
                description=f"**{member.name}#{member.discriminator}** a √©t√© autoris√© manuellement",
                color=0x2ecc71
            )
            embed.add_field(name="üëÆ Autoris√© par", value=ctx.author.mention, inline=False)
            embed.add_field(name="üîì Acc√®s", value="Acc√®s complet au serveur accord√©", inline=False)

            await ctx.send(embed=embed)

            # Notifier l'utilisateur
            try:
                user_embed = discord.Embed(
                    title="‚úÖ AUTORISATION ACCORD√âE",
                    description=f"Vous avez √©t√© autoris√© √† acc√©der au serveur **{ctx.guild.name}** !",
                    color=0x2ecc71
                )
                user_embed.add_field(name="üëÆ Autoris√© par", value=f"{ctx.author.name}#{ctx.author.discriminator}", inline=False)
                user_embed.add_field(name="üéâ Bienvenue", value="Vous pouvez maintenant profiter pleinement du serveur !", inline=False)
                await member.send(embed=user_embed)
            except:
                pass

        except Exception as e:
            embed = discord.Embed(
                title="‚ùå Erreur",
                description=f"Erreur lors de l'autorisation: {str(e)}",
                color=0xe74c3c
            )
            await ctx.send(embed=embed)

    async def check_for_ban_evasion(self, member):
        """D√©tecte automatiquement les tentatives de contournement de ban"""
        if not hasattr(self.bot, 'get_persistent_data'):
            return

        # R√©cup√©rer les utilisateurs super-bannis
        super_banned = self.bot.get_persistent_data('moderation', 'super_banned_users', {})
        banned_users = self.bot.get_persistent_data('moderation', 'banned_users', {})

        # V√©rifications multiples pour d√©tecter les alts
        suspicion_score = 0
        detected_reasons = []

        # 1. V√©rification directe de l'ID (au cas o√π)
        if str(member.id) in super_banned or str(member.id) in banned_users:
            suspicion_score = 100
            detected_reasons.append("ID utilisateur identique")

        # 2. V√©rification de l'avatar
        if member.avatar:
            current_avatar = str(member.avatar.key)
            for banned_data in {**super_banned, **banned_users}.values():
                if banned_data.get('avatar_hash') == current_avatar and current_avatar:
                    suspicion_score += 40
                    detected_reasons.append("Avatar identique")
                    break

        # 3. V√©rification du nom d'utilisateur similaire
        current_username = member.name.lower()
        for banned_data in {**super_banned, **banned_users}.values():
            banned_username = banned_data.get('username', '').lower()
            if banned_username and self.calculate_similarity(current_username, banned_username) > 0.8:
                suspicion_score += 30
                detected_reasons.append("Nom d'utilisateur tr√®s similaire")
                break

        # 4. V√©rification de l'√¢ge du compte (comptes tr√®s r√©cents suspects)
        from datetime import datetime
        account_age_days = (datetime.now() - member.created_at).days
        if account_age_days < 7:  # Compte de moins d'une semaine
            suspicion_score += 20
            detected_reasons.append("Compte tr√®s r√©cent")

        # 5. V√©rification du timing (rejoint peu apr√®s un ban)
        for banned_data in {**super_banned, **banned_users}.values():
            if banned_data.get('ban_time'):
                try:
                    ban_time = datetime.fromisoformat(banned_data['ban_time'])
                    time_since_ban = (datetime.now() - ban_time).total_seconds() / 3600  # en heures
                    if time_since_ban < 24:  # Rejoint dans les 24h apr√®s un ban
                        suspicion_score += 25
                        detected_reasons.append("Rejoint peu apr√®s un bannissement")
                        break
                except:
                    pass

        # 6. V√âRIFICATION DES DONN√âES D'AUTORISATION (NOUVEAU)
        current_auth = self.bot.get_persistent_data('moderation', 'authorized_users', {}).get(str(member.id), {})

        for banned_data in {**super_banned, **banned_users}.values():
            banned_auth = banned_data.get('authorization_data', {})

            # V√©rification IP (hash)
            if current_auth.get('ip_hash') and banned_auth.get('ip_hash'):
                if current_auth['ip_hash'] == banned_auth['ip_hash']:
                    suspicion_score += 60
                    detected_reasons.append("M√™me adresse IP d√©tect√©e")
                    break

            # V√©rification User-Agent (navigateur/appareil)
            if current_auth.get('user_agent') and banned_auth.get('user_agent'):
                if current_auth['user_agent'] == banned_auth['user_agent']:
                    suspicion_score += 30
                    detected_reasons.append("M√™me appareil/navigateur d√©tect√©")

            # V√©rification empreinte d'appareil
            if current_auth.get('device_fingerprint') and banned_auth.get('device_fingerprint'):
                if current_auth['device_fingerprint'] == banned_auth['device_fingerprint']:
                    suspicion_score += 50
                    detected_reasons.append("M√™me empreinte d'appareil d√©tect√©e")

            # V√©rification email (hash)
            if current_auth.get('email_hash') and banned_auth.get('email_hash'):
                if current_auth['email_hash'] == banned_auth['email_hash']:
                    suspicion_score += 70
                    detected_reasons.append("M√™me email d√©tect√©")
                    break

        # Action selon le score de suspicion
        if suspicion_score >= 70:
            # BAN AUTOMATIQUE - Suspicion tr√®s √©lev√©e
            await self.auto_ban_suspected_alt(member, suspicion_score, detected_reasons)
        elif suspicion_score >= 40:
            # QUARANTAINE - Suspicion mod√©r√©e
            await self.quarantine_suspected_alt(member, suspicion_score, detected_reasons)
        elif suspicion_score >= 20:
            # SURVEILLANCE - Suspicion l√©g√®re
            await self.monitor_suspected_alt(member, suspicion_score, detected_reasons)

    def calculate_similarity(self, str1, str2):
        """Calcule la similarit√© entre deux cha√Ænes"""
        if not str1 or not str2:
            return 0

        # Algorithme de distance de Levenshtein simplifi√©
        len1, len2 = len(str1), len(str2)
        if len1 == 0:
            return 0 if len2 == 0 else 0
        if len2 == 0:
            return 0

        # Calcul simple de similarit√©
        matches = sum(1 for a, b in zip(str1, str2) if a == b)
        return matches / max(len1, len2)

    async def auto_ban_suspected_alt(self, member, score, reasons):
        """Ban automatique d'un compte alternatif d√©tect√©"""
        try:
            reason = f"D√âTECTION AUTOMATIQUE ALT - Score: {score}% - Raisons: {', '.join(reasons)}"

            # Ban imm√©diat
            await member.ban(reason=reason, delete_message_days=1)

            # Log critique
            embed = discord.Embed(
                title="üö® BAN AUTOMATIQUE - COMPTE ALTERNATIF D√âTECT√â",
                description=f"**{member.name}#{member.discriminator}** ({member.id})",
                color=0x8b0000
            )
            embed.add_field(name="üéØ Score de suspicion", value=f"{score}%", inline=True)
            embed.add_field(name="üîç Raisons d√©tect√©es", value="\n".join(f"‚Ä¢ {reason}" for reason in reasons), inline=False)
            embed.add_field(name="‚ö° Action", value="**BAN AUTOMATIQUE IMM√âDIAT**", inline=False)

            # Envoyer dans les logs
            logs_channel = discord.utils.get(member.guild.channels, name="logs")
            if logs_channel:
                await logs_channel.send(embed=embed)

            logger.critical(f"BAN AUTOMATIQUE ALT: {member.name} - Score: {score}% - Raisons: {reasons}")

        except Exception as e:
            logger.error(f"Erreur ban automatique alt: {e}")

    async def quarantine_suspected_alt(self, member, score, reasons):
        """Met en quarantaine un compte suspect"""
        try:
            # Cr√©er ou r√©cup√©rer le r√¥le de quarantaine
            quarantine_role = discord.utils.get(member.guild.roles, name="üîí Quarantaine")
            if not quarantine_role:
                quarantine_role = await member.guild.create_role(
                    name="üîí Quarantaine",
                    color=0xff6b6b,
                    reason="R√¥le de quarantaine automatique"
                )

                # Configurer les permissions (aucun acc√®s)
                for channel in member.guild.channels:
                    try:
                        await channel.set_permissions(quarantine_role, read_messages=False, send_messages=False)
                    except:
                        pass

            # Appliquer la quarantaine
            await member.add_roles(quarantine_role, reason=f"Quarantaine automatique - Score suspicion: {score}%")

            # Log d'alerte
            embed = discord.Embed(
                title="‚ö†Ô∏è QUARANTAINE AUTOMATIQUE - COMPTE SUSPECT",
                description=f"**{member.name}#{member.discriminator}** ({member.id})",
                color=0xff6b6b
            )
            embed.add_field(name="üéØ Score de suspicion", value=f"{score}%", inline=True)
            embed.add_field(name="üîç Raisons d√©tect√©es", value="\n".join(f"‚Ä¢ {reason}" for reason in reasons), inline=False)
            embed.add_field(name="üîí Action", value="**QUARANTAINE APPLIQU√âE**", inline=False)

            logs_channel = discord.utils.get(member.guild.channels, name="logs")
            if logs_channel:
                await logs_channel.send(embed=embed)

            logger.warning(f"QUARANTAINE ALT: {member.name} - Score: {score}% - Raisons: {reasons}")

        except Exception as e:
            logger.error(f"Erreur quarantaine alt: {e}")

    async def monitor_suspected_alt(self, member, score, reasons):
        """Surveille un compte l√©g√®rement suspect"""
        try:
            embed = discord.Embed(
                title="üëÅÔ∏è SURVEILLANCE - COMPTE L√âG√àREMENT SUSPECT",
                description=f"**{member.name}#{member.discriminator}** ({member.id})",
                color=0xffa500
            )
            embed.add_field(name="üéØ Score de suspicion", value=f"{score}%", inline=True)
            embed.add_field(name="üîç Raisons d√©tect√©es", value="\n".join(f"‚Ä¢ {reason}" for reason in reasons), inline=False)
            embed.add_field(name="üëÅÔ∏è Action", value="**SURVEILLANCE ACTIV√âE**", inline=False)

            logs_channel = discord.utils.get(member.guild.channels, name="logs")
            if logs_channel:
                await logs_channel.send(embed=embed)

            logger.info(f"SURVEILLANCE ALT: {member.name} - Score: {score}% - Raisons: {reasons}")

        except Exception as e:
            logger.error(f"Erreur surveillance alt: {e}")

async def setup(bot):
    await bot.add_cog(Moderation(bot))
